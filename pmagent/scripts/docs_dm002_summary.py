"""
DM-002 summary: orchestrator-level view of control.kb_document.

- Reads from control.kb_document (read-only).
- Summarizes counts by:
    - status
    - canonical vs non-canonical
    - coarse path prefix (SSOT, archive, other)
- Writes a markdown report:
    docs/analysis/DOC_DM002_SUMMARY.md

No file moves or DB writes are performed here.
"""

from __future__ import annotations

import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple

import psycopg

REPO_ROOT = Path(__file__).resolve().parents[2]
sys.path.insert(0, str(REPO_ROOT))

from scripts.config.env import get_rw_dsn  # noqa: E402  # reuse RW DSN; reads only in practice

OUT_PATH = REPO_ROOT / "docs" / "analysis" / "DOC_DM002_SUMMARY.md"


@dataclass
class StatusCounts:
    status: str
    count: int


@dataclass
class PrefixCounts:
    label: str
    count: int


def fetch_status_counts(conn: psycopg.Connection) -> List[StatusCounts]:
    rows: List[StatusCounts] = []
    with conn.cursor() as cur:
        cur.execute(
            """
            SELECT COALESCE(status, 'unclassified') AS status,
                   COUNT(*) AS count
            FROM control.kb_document
            GROUP BY COALESCE(status, 'unclassified')
            ORDER BY status
            """
        )
        for status, count in cur.fetchall():
            rows.append(StatusCounts(status=status, count=count))
    return rows


def fetch_canonical_counts(conn: psycopg.Connection) -> Tuple[int, int, int]:
    """
    Returns:
      canonical_count
      non_canonical_count
      null_flag_count (is_canonical IS NULL)
    """
    with conn.cursor() as cur:
        cur.execute(
            """
            SELECT
              SUM(CASE WHEN is_canonical = TRUE THEN 1 ELSE 0 END) AS canonical_count,
              SUM(CASE WHEN is_canonical = FALSE THEN 1 ELSE 0 END) AS non_canonical_count,
              SUM(CASE WHEN is_canonical IS NULL THEN 1 ELSE 0 END) AS null_flag_count
            FROM control.kb_document
            """
        )
        row = cur.fetchone()
        if row is None:
            return 0, 0, 0
        canonical_count, non_canonical_count, null_flag_count = row
        return int(canonical_count or 0), int(non_canonical_count or 0), int(null_flag_count or 0)


def fetch_prefix_counts(conn: psycopg.Connection) -> List[PrefixCounts]:
    """
    Coarse path buckets:
      - SSOT: path LIKE 'docs/SSOT/%'
      - Archive: path LIKE 'archive/%'
      - Other: everything else
    """
    with conn.cursor() as cur:
        cur.execute(
            """
            SELECT
              SUM(CASE WHEN path LIKE 'docs/SSOT/%' THEN 1 ELSE 0 END) AS ssot_count,
              SUM(CASE WHEN path LIKE 'archive/%' THEN 1 ELSE 0 END) AS archive_count,
              SUM(CASE WHEN path NOT LIKE 'docs/SSOT/%'
                        AND path NOT LIKE 'archive/%' THEN 1 ELSE 0 END) AS other_count
            FROM control.kb_document
            """
        )
        row = cur.fetchone()
        if row is None:
            return []

        ssot_count, archive_count, other_count = row

    return [
        PrefixCounts(label="docs/SSOT/** (SSOT)", count=int(ssot_count or 0)),
        PrefixCounts(label="archive/**", count=int(archive_count or 0)),
        PrefixCounts(label="other", count=int(other_count or 0)),
    ]


def write_markdown(
    status_counts: List[StatusCounts],
    canonical_counts: Tuple[int, int, int],
    prefix_counts: List[PrefixCounts],
) -> None:
    canonical_count, non_canonical_count, null_flag_count = canonical_counts

    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with OUT_PATH.open("w", encoding="utf-8") as f:
        f.write("# DM-002 Document Classification Summary\n\n")
        f.write("This report is generated by `docs_dm002_summary.py`.\n")
        f.write("It provides an orchestrator-level view of the doc registry.\n\n")

        f.write("## Canonical vs Non-Canonical\n\n")
        f.write(f"- Canonical (`is_canonical = TRUE`): **{canonical_count}**\n")
        f.write(f"- Non-canonical (`is_canonical = FALSE`): **{non_canonical_count}**\n")
        f.write(f"- Unset (`is_canonical IS NULL`): **{null_flag_count}**\n\n")

        f.write("## Status Breakdown\n\n")
        if not status_counts:
            f.write("No rows found in `control.kb_document`.\n\n")
        else:
            for row in status_counts:
                f.write(f"- `{row.status}`: **{row.count}**\n")
            f.write("\n")

        f.write("## Path Prefix Buckets\n\n")
        for pc in prefix_counts:
            f.write(f"- {pc.label}: **{pc.count}**\n")
        f.write("\n")

        f.write("## Notes\n\n")
        f.write(
            "- `status` values come from DM-001 (initially) and DM-002 sync.\n"
            "- Future phases may introduce `needs_review` or `archived` statuses.\n"
            "- This report is read-only; it does not change the DB or move files.\n"
        )

    print(f"Wrote DM-002 summary to: {OUT_PATH}")


def main() -> None:
    dsn = get_rw_dsn()
    with psycopg.connect(dsn) as conn:
        status_counts = fetch_status_counts(conn)
        canonical_counts = fetch_canonical_counts(conn)
        prefix_counts = fetch_prefix_counts(conn)

    write_markdown(status_counts, canonical_counts, prefix_counts)

    canonical_count, non_canonical_count, null_flag_count = canonical_counts
    print("DM-002 summary:")
    print(f"  Canonical      : {canonical_count}")
    print(f"  Non-canonical  : {non_canonical_count}")
    print(f"  is_canonical NULL: {null_flag_count}")
    print("  Status buckets :")
    for row in status_counts:
        print(f"    {row.status}: {row.count}")
    print("  Path buckets   :")
    for pc in prefix_counts:
        print(f"    {pc.label}: {pc.count}")


if __name__ == "__main__":
    main()
