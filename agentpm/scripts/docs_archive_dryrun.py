"""
DM-00X: archive dry-run planner.

This script:
- Reads from control.kb_document (read-only).
- Selects a narrow subset of rows that are clear archive candidates, e.g.:
    - status = 'archive_candidate'
    - path LIKE 'archive/evidence_v0.0.9_pre/%'
    - plus some top-level backup bundles
- Produces a *plan only*:
    docs/analysis/DOC_ARCHIVE_DRYRUN.md

NO FILES ARE MOVED OR DELETED.

This is a planning tool for the Orchestrator to inspect before any real moves exist.
"""

from __future__ import annotations

import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List

REPO_ROOT = Path(__file__).resolve().parents[2]
sys.path.insert(0, str(REPO_ROOT))

import psycopg

from scripts.config.env import get_rw_dsn

OUT_PATH = REPO_ROOT / "docs" / "analysis" / "DOC_ARCHIVE_DRYRUN.md"


@dataclass
class ArchiveCandidate:
    path: str
    suggested_target: str
    reason: str


def fetch_candidates(conn: psycopg.Connection) -> List[ArchiveCandidate]:
    """
    Fetch a *narrow* set of archive candidates for dry-run planning.

    Rules:
    - status = 'archive_candidate'
    - AND (path LIKE 'archive/evidence_v0.0.9_pre/%'
           OR path LIKE 'archive/%backup%'
           OR path LIKE 'archive/%evidence%')

    This is intentionally conservative and focused on clearly archival trees.
    """
    rows: List[ArchiveCandidate] = []
    with conn.cursor() as cur:
        cur.execute(
            """
            SELECT path, status
            FROM control.kb_document
            WHERE status = 'archive_candidate'
              AND (
                    path LIKE 'archive/evidence_v0.0.9_pre/%'
                 OR path LIKE 'archive/%evidence%'
                 OR path LIKE 'archive/%backup%'
              )
            ORDER BY path
            """
        )
        for path, status in cur.fetchall():
            # Compute a hypothetical target under archive/docs/...
            # Example: archive/evidence_v0.0.9_pre/foo.txt
            #   -> archive/docs/evidence_v0.0.9_pre/foo.txt
            rel = path[len("archive/") :] if path.startswith("archive/") else path
            target = f"archive/docs/{rel}"
            reason = f"status={status}"
            rows.append(ArchiveCandidate(path=path, suggested_target=target, reason=reason))
    return rows


def add_top_level_backup_candidates(candidates: List[ArchiveCandidate]) -> None:
    """
    Add a small set of top-level backup bundles that are not in kb_document,
    but are clearly archival (e.g., backup-safety-rules-*.tar.gz).

    This is derived from the orphan report, but stays narrow by pattern.
    """
    top = REPO_ROOT
    for entry in top.iterdir():
        name = entry.name
        if entry.is_file() and name.startswith("backup-safety-rules-"):
            target = f"archive/docs/backups/{name}"
            candidates.append(
                ArchiveCandidate(
                    path=name,
                    suggested_target=target,
                    reason="top-level backup bundle (orphan candidate)",
                )
            )
        elif entry.is_dir() and name == "backups":
            target = "archive/docs/backups/"
            candidates.append(
                ArchiveCandidate(
                    path=name + "/",
                    suggested_target=target,
                    reason="top-level backups dir (orphan candidate)",
                )
            )


def write_plan(candidates: List[ArchiveCandidate]) -> None:
    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with OUT_PATH.open("w", encoding="utf-8") as f:
        f.write("# Archive Dry-Run Plan\n\n")
        f.write("This file is generated by `docs_archive_dryrun.py`.\n")
        f.write("It is a *dry-run* plan only. No files have been moved or deleted.\n\n")

        f.write("## Summary\n\n")
        f.write(f"- Total archive candidates in this plan: **{len(candidates)}**\n\n")

        if not candidates:
            f.write("No candidates matched the narrow DM-00X criteria.\n")
            return

        f.write("## Proposed Moves (Dry-Run Only)\n\n")
        f.write(
            "For each entry below, `from` is the current path and `to` is the suggested\n"
            "archive location under `archive/docs/...`. This is informational only.\n\n"
        )

        for cand in candidates:
            f.write(f"- from: `{cand.path}`\n")
            f.write(f"  to  : `{cand.suggested_target}`\n")
            f.write(f"  reason: {cand.reason}\n\n")

        f.write("## Notes\n\n")
        f.write(
            "- This plan is intentionally narrow and focuses on clearly archival trees.\n"
            "- No filesystem changes have been made.\n"
            "- A future `archive-apply` tool would read a refined plan and perform\n"
            "  actual moves with a receipt, but that tool does not exist yet.\n"
        )

    print(f"Wrote archive dry-run plan to: {OUT_PATH}")


def main() -> None:
    dsn = get_rw_dsn()
    with psycopg.connect(dsn) as conn:
        conn.autocommit = False
        candidates = fetch_candidates(conn)

    # Augment with top-level backup bundles (filesystem-only, narrow patterns)
    add_top_level_backup_candidates(candidates)

    write_plan(candidates)

    print("Archive dry-run completed:")
    print(f"  Total candidates in plan: {len(candidates)}")
    print(f"  Plan path: {OUT_PATH}")


if __name__ == "__main__":
    main()
