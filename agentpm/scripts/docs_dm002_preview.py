"""
DM-002 preview classifier.

Reads DOC_DUPLICATES_REPORT.md, groups duplicate files, and proposes:
- One canonical doc per group
- Remaining docs as archive_candidate

Writes an analysis file:
- docs/analysis/DOC_DM002_CANONICAL_PREVIEW.md

This script:
- Does NOT touch the DB.
- Does NOT move/delete files.
"""

from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple

REPO_ROOT = Path(__file__).resolve().parents[2]
DUPES_PATH = REPO_ROOT / "docs" / "analysis" / "DOC_DUPLICATES_REPORT.md"
OUT_PATH = REPO_ROOT / "docs" / "analysis" / "DOC_DM002_CANONICAL_PREVIEW.md"


@dataclass
class Group:
    name: str
    files: List[str]


def load_groups() -> List[Group]:
    """
    Parse DOC_DUPLICATES_REPORT.md.

    Expected structure (approximate, tolerant):
    - Lines starting with '## ' mark group boundaries (e.g., '## Group 1').
    - Lines starting with '-' list files, possibly with extra info.
    """
    if not DUPES_PATH.exists():
        raise SystemExit(f"duplicates report not found: {DUPES_PATH}")

    groups: List[Group] = []
    current_name: str | None = None
    current_files: List[str] = []

    group_header_re = re.compile(r"^###\s+Duplicate\s+Group\s+(\d+)", re.IGNORECASE)

    with DUPES_PATH.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.rstrip("\n")

            m = group_header_re.match(line)
            if m:
                # flush previous group
                if current_name is not None and current_files:
                    groups.append(Group(name=current_name, files=current_files))
                current_name = f"Group {m.group(1)}"
                current_files = []
                continue

            if line.lstrip().startswith("- `"):
                # bullet line with backticked path
                bullet = line.lstrip()[2:].strip()  # Remove "- "
                # Extract content between first pair of backticks
                if bullet.startswith("`") and "`" in bullet[1:]:
                    end_idx = bullet.index("`", 1)
                    path = bullet[1:end_idx].strip()
                    if path and "/" in path:  # Only add if it looks like a path
                        current_files.append(path)

    if current_name is not None and current_files:
        groups.append(Group(name=current_name, files=current_files))

    return groups


def score_path(path: str) -> Tuple[int, int, int, str]:
    """
    Score a path for canonical selection.

    Lower tuple sorts first (better canonical candidate):

    1. is_not_archive (0 if under archive/, 1 otherwise; we invert later)
    2. is_ssot (0 if under docs/SSOT/, 1 otherwise)
    3. depth (fewer segments preferred)
    4. path string (lexicographical tiebreaker)

    Note: we deliberately sort by (is_ssot, is_archive, depth, path) in choose_canonical().
    """
    p = path.strip()
    parts = p.split("/")

    is_archive = any(part.lower().startswith("archive") for part in parts)
    is_ssot = p.startswith("docs/SSOT/") or p.startswith("docs/SSOT\\")

    depth = len(parts)

    # We'll order later as (is_ssot_flag, is_archive_flag, depth, path)
    return int(not is_ssot), int(is_archive), depth, p


def choose_canonical(group: Group) -> Tuple[str, List[str]]:
    """
    Choose one canonical file and the remaining archive candidates.
    """
    if not group.files:
        raise ValueError(f"group {group.name} has no files")

    sorted_files = sorted(group.files, key=score_path)
    canonical = sorted_files[0]
    others = [f for f in sorted_files if f != canonical]
    return canonical, others


def write_preview(groups: List[Group]) -> None:
    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)

    with OUT_PATH.open("w", encoding="utf-8") as f:
        f.write("# DM-002 Canonical vs Archive Preview\n\n")
        f.write("This file is generated by agentpm/scripts/docs_dm002_preview.py.\n")
        f.write("It is a *preview only* and does not change the DB or move files.\n\n")
        f.write("Heuristics:\n")
        f.write("- Prefer paths under `docs/SSOT/` as canonical.\n")
        f.write("- Otherwise prefer paths not under `archive/`.\n")
        f.write("- Then prefer shallower (shorter) paths.\n")
        f.write("- Then prefer lexicographically smallest path.\n\n")

        total_groups = len(groups)
        f.write(f"Total groups: {total_groups}\n\n")

        for group in groups:
            if not group.files:
                continue

            try:
                canonical, others = choose_canonical(group)
            except Exception as exc:  # pragma: no cover (defensive)
                f.write(f"## {group.name}\n\n")
                f.write(f"Error choosing canonical: {exc}\n\n")
                continue

            f.write(f"## {group.name}\n\n")
            f.write(f"**Canonical:** `{canonical}`\n\n")

            if others:
                f.write("**Archive candidates:**\n\n")
                for path in others:
                    f.write(f"- `{path}`\n")
            else:
                f.write("No archive candidates (single-file group).\n")

            f.write("\n")

    print(f"Wrote DM-002 preview to: {OUT_PATH}")


def main() -> None:
    groups = load_groups()
    if not groups:
        print(f"No groups found in {DUPES_PATH}")
        return
    write_preview(groups)


if __name__ == "__main__":
    main()
